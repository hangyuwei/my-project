{"version":3,"sources":["index.js","signer.js","utils.js","utils.lang.js","keyvalue.js","utils.http.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA,ACHA;AHUA,ACHA,ACHA,ACHA;AHUA,ACHA,ACHA,ACHA;AHUA,AIZA,AHSA,ACHA,ACHA;AHUA,AIZA,AHSA,ACHA,ACHA;AHUA,AIZA,AHSA,ACHA,ACHA;AHUA,AIZA,AHSA,AIZA,AHSA,ACHA;AHUA,AIZA,AHSA,AIZA,AHSA,ACHA;AHUA,AIZA,AHSA,AIZA,AHSA,ACHA;AHUA,AIZA,AHSA,AIZA,AHSA,ACHA;AHUA,AIZA,AHSA,AIZA,AHSA,ACHA;AHUA,AIZA,AHSA,AIZA,AHSA,ACHA;AHUA,AIZA,AHSA,AIZA,AHSA,ACHA;AHUA,AIZA,AHSA,AIZA,AHSA,ACHA;AHUA,AIZA,AHSA,AIZA,AHSA,ACHA;AHUA,AIZA,AHSA,AIZA,AHSA,ACHA;AHUA,AIZA,AHSA,AIZA,AHSA,ACHA;AHUA,AIZA,AHSA,AIZA,AHSA,ACHA;AHUA,AIZA,AHSA,AIZA,AHSA,ACHA;AHUA,AIZA,AHSA,AIZA,AHSA,ACHA;AHUA,AIZA,AHSA,AIZA,AHSA;AFOA,AIZA,AHSA,AIZA,AHSA;AFOA,AIZA,AHSA,AIZA,AHSA;AFOA,AIZA,AHSA,AIZA,AHSA;AFOA,AIZA,AHSA,AIZA,AHSA;AFOA,AIZA,AHSA,AIZA,AHSA;AFOA,AIZA,AHSA,AIZA,AHSA;AFOA,AIZA,AHSA,AIZA,AHSA;AFOA,AIZA,AHSA,AIZA;ALgBA,AIZA,AHSA,AIZA;ALgBA,AIZA,AHSA,AIZA;ALgBA,AIZA,AHSA,AIZA;ALgBA,AIZA,AHSA,AIZA;ALgBA,AIZA,AHSA,AIZA;ALgBA,AIZA,AHSA,AIZA;ALgBA,AIZA,AHSA,AIZA;ALgBA,AIZA,AHSA,AIZA;ALgBA,AIZA,AHSA,AIZA;ADIA,AHSA,AIZA;ADIA,AHSA,AIZA;ADIA,AHSA,AIZA;ADIA,AHSA,AIZA;ADIA,AHSA,AIZA;ADIA,AHSA,AIZA;ADIA,AHSA,AIZA;ADIA,AHSA,AIZA;ADIA,AHSA,AIZA;ADIA,AHSA,AIZA;ADIA,AHSA,AIZA;ADIA,AHSA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.sign = void 0;\nconst clone = require(\"clone\");\nconst signer_1 = require(\"./signer\");\nconst utils_1 = require(\"./utils\");\n__exportStar(require(\"./keyvalue\"), exports);\n__exportStar(require(\"./signer\"), exports);\n__exportStar(require(\"./utils.http\"), exports);\n__exportStar(require(\"./utils.lang\"), exports);\n__exportStar(require(\"./utils\"), exports);\nfunction sign(options) {\n    const { secretId, secretKey, method, url, service, withSignedParams, isCloudApi, includeKeys, excludeKeys } = options;\n    // isCloudApi 为 true, 说明使用 cloud api v3, 返回签名值中不能携带 signedParams\n    let validWithSignedParams = withSignedParams;\n    if (isCloudApi === true && withSignedParams === true) {\n        console.warn('isCloudApi 和 withSignedParams 参数同时为 true, withSignedParams 会自动转为 false');\n        validWithSignedParams = false;\n    }\n    const signer = new signer_1.Signer({ secretId, secretKey }, service || 'tcb');\n    const headers = clone(options.headers || {});\n    const params = clone(options.params === undefined ? '' : options.params);\n    const timestamp = options.timestamp || utils_1.second() - 1;\n    const signatureInfo = signer.tc3sign(method, url, headers, params, timestamp, {\n        withSignedParams: validWithSignedParams,\n        isCloudApi,\n        includeKeys,\n        excludeKeys\n    });\n    return {\n        authorization: signatureInfo.authorization,\n        timestamp: signatureInfo.timestamp,\n        multipart: signatureInfo.multipart\n    };\n}\nexports.sign = sign;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Signer = exports.signedParamsSeparator = void 0;\nconst crypto = require(\"crypto\");\nconst url_1 = require(\"url\");\nconst util = require(\"util\");\nconst isStream = require(\"is-stream\");\nconst utils_1 = require(\"./utils\");\nconst utils_lang_1 = require(\"./utils.lang\");\nconst keyvalue_1 = require(\"./keyvalue\");\nconst debug = util.debuglog('@cloudbase/signature');\nexports.signedParamsSeparator = ';';\nconst HOST_KEY = 'host';\nconst CONTENT_TYPE_KEY = 'content-type';\nvar MIME;\n(function (MIME) {\n    MIME[\"MULTIPART_FORM_DATA\"] = \"multipart/form-data\";\n    MIME[\"APPLICATION_JSON\"] = \"application/json\";\n})(MIME || (MIME = {}));\nclass Signer {\n    constructor(credential, service, options = {}) {\n        this.credential = credential;\n        this.service = service;\n        this.algorithm = 'TC3-HMAC-SHA256';\n        this.options = options;\n    }\n    static camSafeUrlEncode(str) {\n        return encodeURIComponent(str)\n            .replace(/!/g, '%21')\n            .replace(/'/g, '%27')\n            .replace(/\\(/g, '%28')\n            .replace(/\\)/g, '%29')\n            .replace(/\\*/g, '%2A');\n    }\n    /**\n     * 将一个对象处理成 KeyValue 形式，嵌套的对象将会被处理成字符串，Key转换成小写字母\n     * @param {Object}  obj - 待处理的对象\n     * @param {Object}  options\n     * @param {Boolean} options.enableBuffer\n     */\n    static formatKeyAndValue(obj, options = {}) {\n        if (!utils_lang_1.isPlainObject(obj)) {\n            return obj;\n        }\n        // enableValueToLowerCase：头部字段，要求小写，其他数据不需要小写，所以这里避免转小写\n        const { multipart, enableValueToLowerCase = false, selectedKeys, filter } = options;\n        const kv = {};\n        Object.keys(obj || {}).forEach((key) => {\n            // NOTE: 客户端类型在服务端可能会丢失\n            const lowercaseKey = Signer.camSafeUrlEncode(key.toLowerCase().trim());\n            // 过滤 Key，服务端接收到的数据，可能含有未签名的 Key，通常是签名的时候被过滤掉的流，数据量可能会比较大\n            // 所以这里提供一个过滤的判断，避免不必要的计算\n            // istanbul ignore next\n            if (Array.isArray(selectedKeys) && !selectedKeys.includes(lowercaseKey)) {\n                return;\n            }\n            // istanbul ignore next\n            if (typeof filter === 'function') {\n                if (filter(key, obj[key], options)) {\n                    return;\n                }\n            }\n            // istanbul ignore else\n            if (key && obj[key] !== undefined) {\n                if (lowercaseKey === CONTENT_TYPE_KEY) {\n                    // multipart/form-data; boundary=???\n                    if (obj[key].startsWith(MIME.MULTIPART_FORM_DATA)) {\n                        kv[lowercaseKey] = MIME.MULTIPART_FORM_DATA;\n                    }\n                    else {\n                        kv[lowercaseKey] = obj[key];\n                    }\n                    return;\n                }\n                if (isStream(obj[key])) {\n                    // 这里如果是个文件流，在发送的时候可以识别\n                    // 服务端接收到数据之后传到这里判断不出来的\n                    // 所以会进入后边的逻辑\n                    return;\n                }\n                if (utils_1.isNodeEnv() && Buffer.isBuffer(obj[key])) {\n                    if (multipart) {\n                        kv[lowercaseKey] = obj[key];\n                    }\n                    else {\n                        kv[lowercaseKey] = enableValueToLowerCase\n                            ? utils_1.stringify(obj[key]).trim().toLowerCase()\n                            : utils_1.stringify(obj[key]).trim();\n                    }\n                }\n                else {\n                    kv[lowercaseKey] = enableValueToLowerCase\n                        ? utils_1.stringify(obj[key]).trim().toLowerCase()\n                        : utils_1.stringify(obj[key]).trim();\n                }\n            }\n        });\n        return kv;\n    }\n    static calcParamsHash(params, options = {}) {\n        debug(params, 'calcParamsHash');\n        if (utils_lang_1.isString(params)) {\n            return utils_1.sha256hash(params);\n        }\n        // 只关心业务参数，不关心以什么类型的 Content-Type 传递的\n        // 所以 application/json multipart/form-data 计算方式是相同的\n        /* eslint-disable no-param-reassign */\n        const includeKeys = options.includeKeys || keyvalue_1.SortedKeyValue.kv(params).keys();\n        /* eslint-enable no-param-reassign */\n        const excludeKeys = new Set(options.excludeKeys);\n        const hash = crypto.createHash('sha256');\n        for (const key of includeKeys) {\n            if (excludeKeys.has(key)) {\n                continue;\n            }\n            // istanbul ignore next\n            if (!params[key]) {\n                continue;\n            }\n            // istanbul ignore next\n            if (isStream(params[key])) {\n                continue;\n            }\n            if (Array.isArray(options.hashedKeys)) {\n                options.hashedKeys.push(key);\n            }\n            // string && buffer\n            hash.update(`&${key}=`);\n            hash.update(params[key]);\n            hash.update('\\r\\n');\n        }\n        return hash.digest(options.encoding || 'hex');\n    }\n    /**\n     * 计算签名信息\n     * 注：默认是tcb签名算法，传入 options.isCloudApi=true，则使用云API V3签名算法\n     * 云API V3算法文档：https://cloud.tencent.com/document/api/598/38504#NodeJS\n     *\n     * @param {string} method       - Http Verb：GET/get POST/post 区分大小写\n     * @param {string} url          - 地址：http://abc.org/api/v1?a=1&b=2\n     * @param {Object} headers      - 需要签名的头部字段\n     * @param {string} params       - 请求参数\n     * @param {number} [timestamp]  - 签名时间戳\n     * @param {object} [options]    - 可选参数\n     */\n    tc3sign(method, url, headers, params, timestamp, options = {}) {\n        /* eslint-disable no-param-reassign */\n        timestamp = timestamp || utils_1.second();\n        /* eslint-enable no-param-reassign */\n        const urlInfo = url_1.parse(url);\n        const formatedHeaders = Signer.formatKeyAndValue(headers, {\n            enableValueToLowerCase: true\n        });\n        const headerKV = keyvalue_1.SortedKeyValue.kv(formatedHeaders);\n        const signedHeaders = headerKV.keys();\n        const canonicalHeaders = `${headerKV.toString(':', '\\n')}\\n`;\n        const { enableHostCheck = true, enableContentTypeCheck = true, isCloudApi = false } = options;\n        if (enableHostCheck && headerKV.get(HOST_KEY) !== urlInfo.host) {\n            throw new TypeError(`host:${urlInfo.host} in url must be equals to host:${headerKV.get('host')} in headers`);\n        }\n        if (enableContentTypeCheck && !headerKV.get(CONTENT_TYPE_KEY)) {\n            throw new TypeError(`${CONTENT_TYPE_KEY} field must in headers`);\n        }\n        const multipart = headerKV\n            .get(CONTENT_TYPE_KEY)\n            .startsWith(MIME.MULTIPART_FORM_DATA);\n        const formatedParams = (() => {\n            // case 1：类似云API签名方式，整体 stringify 一下\n            if (isCloudApi) {\n                return params === '' ? '' : JSON.stringify(params);\n            }\n            // case 2: tcbapi 签名方式，需要对参数进行排序处理\n            return method.toUpperCase() === 'GET'\n                ? ''\n                : Signer.formatKeyAndValue(params, {\n                    multipart\n                });\n        })();\n        const signedParams = [];\n        const hashedPayload = Signer.calcParamsHash(formatedParams, {\n            includeKeys: options.includeKeys,\n            excludeKeys: options.excludeKeys,\n            hashedKeys: signedParams\n        });\n        const signedUrl = isCloudApi\n            ? urlInfo.pathname\n            : url.replace(/^https?:/, '').split('?')[0];\n        const canonicalRequest = `${method}\\n${signedUrl}\\n${urlInfo.query || ''}\\n${canonicalHeaders}\\n${signedHeaders.join(';')}\\n${hashedPayload}`;\n        debug(canonicalRequest, 'canonicalRequest\\n\\n');\n        const date = utils_1.formateDate(timestamp);\n        const { service } = this;\n        const { algorithm } = this;\n        const credentialScope = `${date}/${service}/tc3_request`;\n        const stringToSign = `${algorithm}\\n${timestamp}\\n${credentialScope}\\n${utils_1.sha256hash(canonicalRequest)}`;\n        debug(stringToSign, 'stringToSign\\n\\n');\n        const secretDate = utils_1.sha256hmac(date, `TC3${this.credential.secretKey}`);\n        const secretService = utils_1.sha256hmac(service, secretDate);\n        const secretSigning = utils_1.sha256hmac('tc3_request', secretService);\n        const signature = utils_1.sha256hmac(stringToSign, secretSigning, 'hex');\n        debug(secretDate.toString('hex'), 'secretDate');\n        debug(secretService.toString('hex'), 'secretService');\n        debug(secretSigning.toString('hex'), 'secretSigning');\n        debug(signature.toString('hex'), 'signature');\n        let { withSignedParams = false } = options;\n        if ((options.includeKeys && options.includeKeys.length > 0) ||\n            (options.excludeKeys && options.excludeKeys.length > 0)) {\n            withSignedParams = true;\n        }\n        return {\n            // 需注意该字段长度\n            // https://stackoverflow.com/questions/686217/maximum-on-http-header-values\n            // https://www.tutorialspoint.com/What-is-the-maximum-size-of-HTTP-header-values\n            authorization: `${algorithm} Credential=${this.credential.secretId}/${credentialScope},${withSignedParams ? ` SignedParams=${signedParams.join(';')},` : ''} SignedHeaders=${signedHeaders.join(';')}, Signature=${signature}`,\n            signedParams,\n            signedHeaders,\n            signature,\n            timestamp,\n            multipart\n        };\n    }\n}\nexports.Signer = Signer;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isNodeEnv = exports.sha256hmac = exports.sha256hash = exports.stringify = exports.second = exports.formateDate = void 0;\nconst crypto = require(\"crypto\");\nfunction formateDate(timestamp) {\n    return new Date(timestamp * 1000).toISOString().split('T')[0];\n}\nexports.formateDate = formateDate;\nfunction second() {\n    // istanbul ignore next\n    return Math.floor(new Date().getTime() / 1000);\n}\nexports.second = second;\nfunction stringify(v) {\n    return typeof v !== 'string' ? JSON.stringify(v) : v;\n}\nexports.stringify = stringify;\nfunction sha256hash(string, encoding = 'hex') {\n    return crypto.createHash('sha256').update(string).digest(encoding);\n}\nexports.sha256hash = sha256hash;\nfunction sha256hmac(string, secret = '', encoding) {\n    return crypto.createHmac('sha256', secret).update(string).digest(encoding);\n}\nexports.sha256hmac = sha256hmac;\nfunction isNodeEnv() {\n    /* eslint-disable @typescript-eslint/prefer-optional-chain */\n    return process && process.release && process.release.name === 'node';\n}\nexports.isNodeEnv = isNodeEnv;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isPlainObject = exports.isObject = exports.isString = exports.isNumber = void 0;\nfunction isNumber(v) {\n    return v === +v;\n}\nexports.isNumber = isNumber;\nfunction isString(v) {\n    return typeof v === 'string';\n}\nexports.isString = isString;\nfunction isObject(v) {\n    return v !== null && typeof v === 'object' && Array.isArray(v) === false;\n}\nexports.isObject = isObject;\nfunction isPlainObject(v) {\n    return (isObject(v) && [null, Object.prototype].includes(Object.getPrototypeOf(v)));\n}\nexports.isPlainObject = isPlainObject;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SortedKeyValue = void 0;\nconst utils_lang_1 = require(\"./utils.lang\");\nclass SortedKeyValue {\n    constructor(obj, selectkeys) {\n        this._keys = [];\n        this._values = [];\n        this._pairs = [];\n        this._obj = {};\n        if (!utils_lang_1.isObject(obj)) {\n            return this;\n        }\n        // https://stackoverflow.com/questions/5525795/does-javascript-guarantee-object-property-order\n        // https://www.stefanjudis.com/today-i-learned/property-order-is-predictable-in-javascript-objects-since-es2015/\n        Object.keys(obj || {})\n            .sort((l, r) => l.toString().localeCompare(r))\n            .forEach((key) => {\n            if (!selectkeys || selectkeys.includes(key)) {\n                this._keys.push(key);\n                this._values.push(obj[key]);\n                this._pairs.push([key, obj[key]]);\n                this._obj[key.toLowerCase()] = obj[key];\n            }\n        });\n    }\n    static kv(obj, selectkeys) {\n        return new SortedKeyValue(obj, selectkeys);\n    }\n    get(key) {\n        return this._obj[key];\n    }\n    keys() {\n        return this._keys;\n    }\n    values() {\n        return this._values;\n    }\n    pairs() {\n        return this._pairs;\n    }\n    toString(kvSeparator = '=', joinSeparator = '&') {\n        return this._pairs.map((pair) => pair.join(kvSeparator)).join(joinSeparator);\n    }\n}\nexports.SortedKeyValue = SortedKeyValue;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.mustUseFormdata = exports.canUseFormdata = void 0;\nconst utils_1 = require(\"./utils\");\nconst utils_lang_1 = require(\"./utils.lang\");\nconst isStream = require(\"is-stream\");\n/**\n * 是否能够使用 FormData 发送数据\n * @param {any} data - 待发送的数据\n */\nfunction canUseFormdata(data) {\n    let enable = true;\n    /* eslint-disable no-restricted-syntax */\n    for (const key in data) {\n        const value = data[key];\n        if (!isStream(value) &&\n            utils_1.isNodeEnv() &&\n            !Buffer.isBuffer(value) &&\n            !utils_lang_1.isString(value) &&\n            !utils_lang_1.isNumber(value)) {\n            enable = false;\n            break;\n        }\n    }\n    /* eslint-enable no-restricted-syntax */\n    return enable;\n}\nexports.canUseFormdata = canUseFormdata;\n/**\n * 是否一定要通过 FormData 发送数据\n * 如果有 Buffer 和 Stream 必须用 multipart/form-data，如果同时还含有\n * @param {any} data - 待发送的数据\n */\nfunction mustUseFormdata(data) {\n    let must = false;\n    /* eslint-disable no-restricted-syntax */\n    for (const key in data) {\n        const value = data[key];\n        if ((utils_1.isNodeEnv() && Buffer.isBuffer(value)) || isStream(value)) {\n            must = true;\n            break;\n        }\n    }\n    /* eslint-enable no-restricted-syntax */\n    return must;\n}\nexports.mustUseFormdata = mustUseFormdata;\n"]}